<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>有色湍流置换</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
  html,body{margin:0;height:100%;overflow:hidden}
  #cv{position:fixed;top:0;left:0;width:100%;height:100%;z-index:-1}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

const canvas = document.getElementById('cv');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(window.devicePixelRatio);

const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1,1,1,-1,.1,10);
camera.position.z = 1;

/* ------------ 着色器 ------------ */
const vs = `
  varying vec2 vUv;
  void main(){ vUv = uv; gl_Position = vec4(position,1.); }
`;

const fs = `
  precision highp float;
  varying vec2 vUv;
  uniform float uTime;
  uniform vec2 uRes;

  /* 噪声系列 */
  vec3 hash3(vec2 p){
    vec3 q = vec3(dot(p,vec2(127.1,311.7)),
                  dot(p,vec2(269.5,183.3)),
                  dot(p,vec2(419.2,371.9)));
    return -1. + 2.*fract(sin(q)*43758.5453);
  }
  float noise(vec2 p){
    vec2 i = floor(p), f = fract(p);
    vec2 u = f*f*(3.-2.*f);
    return mix(mix(dot(hash3(i+vec2(0,0)).xy, f-vec2(0,0)),
                   dot(hash3(i+vec2(1,0)).xy, f-vec2(1,0)), u.x),
               mix(dot(hash3(i+vec2(0,1)).xy, f-vec2(0,1)),
                   dot(hash3(i+vec2(1,1)).xy, f-vec2(1,1)), u.x), u.y);
  }
  float fbm(vec2 p){
    float v = 0., a = .5;
    for(int i=0;i<6;i++){ v+=a*noise(p); p*=2.; a*=.5; }
    return v;
  }

  /* 彩虹映射 */
  vec3 heat(float t){
    t = clamp(t,0.,1.);
    vec3 c = vec3(1.,.5,.2) + t*vec3(-1.,.5,.8); // 简易彩虹
    return .5 + .5*cos(6.28318*(c+t));
  }

  void main(){
    vec2 uv = vUv;
    float n1 = fbm(uv*3. + uTime*.1);
    float n2 = fbm(uv*4. - uTime*.07);
    vec2 distort = .08*vec2(n1,n2);

    /* 两张渐变色纹理 */
    vec3 cold = vec3(.1,.3,.8);
    vec3 warm = vec3(1.,.4,.2);
    vec3 col = mix(cold,warm, fbm(uv*2. + distort));

    /* 把噪声本身也上色叠上去 */
    float mixFactor = .5 + .5*n1;
    col = mix(col, heat(mixFactor), .35);

    gl_FragColor = vec4(col,1.);
  }
`;

const geo = new THREE.PlaneGeometry(2,2);
const mat = new THREE.ShaderMaterial({
  vertexShader: vs,
  fragmentShader: fs,
  uniforms:{
    uTime:{ value:0 },
    uRes:{ value:new THREE.Vector2() }
  }
});
scene.add(new THREE.Mesh(geo,mat));

/* ------------ 响应式 & 循环 ------------ */
function resize(){
  const w = innerWidth, h = innerHeight;
  renderer.setSize(w,h);
  mat.uniforms.uRes.value.set(w,h);
}
addEventListener('resize',resize);
resize();

const clock = new THREE.Clock();
function loop(){
  requestAnimationFrame(loop);
  mat.uniforms.uTime.value = clock.getElapsedTime();
  renderer.render(scene,camera);
}
loop();
</script>
</body>
</html>
